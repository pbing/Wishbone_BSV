//
// Generated by Bluespec Compiler, version 2023.01 (build 52adafa)
//
// On Tue Feb 14 11:48:40 GMT 2023
//
//
// Ports:
// Name                         I/O  size props
// STALL_O                        O     1
// ACK_O                          O     1
// DAT_O                          O    32 reg
// client_request_get             O    69 reg
// RDY_client_request_get         O     1 reg
// RDY_client_response_put        O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// CYC_I                          I     1
// STB_I                          I     1
// WE_I                           I     1 reg
// ADR_I                          I    32 reg
// SEL_I                          I     4 reg
// DAT_I                          I    32 reg
// client_response_put            I    32 reg
// EN_client_response_put         I     1
// EN_client_request_get          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkWishboneSlaveXactor_32_32_8(CLK,
				     RST_N,

				     CYC_I,
				     STB_I,
				     WE_I,
				     ADR_I,
				     SEL_I,
				     DAT_I,

				     STALL_O,

				     ACK_O,

				     DAT_O,

				     EN_client_request_get,
				     client_request_get,
				     RDY_client_request_get,

				     client_response_put,
				     EN_client_response_put,
				     RDY_client_response_put);
  input  CLK;
  input  RST_N;

  // action method wishbone_put
  input  CYC_I;
  input  STB_I;
  input  WE_I;
  input  [31 : 0] ADR_I;
  input  [3 : 0] SEL_I;
  input  [31 : 0] DAT_I;

  // value method wishbone_stall
  output STALL_O;

  // value method wishbone_ack
  output ACK_O;

  // value method wishbone_dat
  output [31 : 0] DAT_O;

  // actionvalue method client_request_get
  input  EN_client_request_get;
  output [68 : 0] client_request_get;
  output RDY_client_request_get;

  // action method client_response_put
  input  [31 : 0] client_response_put;
  input  EN_client_response_put;
  output RDY_client_response_put;

  // signals for module outputs
  wire [68 : 0] client_request_get;
  wire [31 : 0] DAT_O;
  wire ACK_O, RDY_client_request_get, RDY_client_response_put, STALL_O;

  // ports of submodule m_io_req
  wire [68 : 0] m_io_req$D_IN, m_io_req$D_OUT;
  wire m_io_req$CLR,
       m_io_req$DEQ,
       m_io_req$EMPTY_N,
       m_io_req$ENQ,
       m_io_req$FULL_N;

  // ports of submodule m_io_rsp
  wire [31 : 0] m_io_rsp$D_IN, m_io_rsp$D_OUT;
  wire m_io_rsp$CLR,
       m_io_rsp$DEQ,
       m_io_rsp$EMPTY_N,
       m_io_rsp$ENQ,
       m_io_rsp$FULL_N;

  // ports of submodule m_req_queue
  wire m_req_queue$CLR,
       m_req_queue$DEQ,
       m_req_queue$EMPTY_N,
       m_req_queue$ENQ,
       m_req_queue$FULL_N;

  // remaining internal signals
  wire m_io_req_i_notFull_AND_m_req_queue_i_notFull_A_ETC___d5;

  // value method wishbone_stall
  assign STALL_O = !m_io_req$FULL_N ;

  // value method wishbone_ack
  assign ACK_O = m_io_rsp$EMPTY_N && m_req_queue$EMPTY_N ;

  // value method wishbone_dat
  assign DAT_O = m_io_rsp$D_OUT ;

  // actionvalue method client_request_get
  assign client_request_get = m_io_req$D_OUT ;
  assign RDY_client_request_get = m_io_req$EMPTY_N ;

  // action method client_response_put
  assign RDY_client_response_put = m_io_rsp$FULL_N ;

  // submodule m_io_req
  FIFO2 #(.width(32'd69), .guarded(1'd1)) m_io_req(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(m_io_req$D_IN),
						   .ENQ(m_io_req$ENQ),
						   .DEQ(m_io_req$DEQ),
						   .CLR(m_io_req$CLR),
						   .D_OUT(m_io_req$D_OUT),
						   .FULL_N(m_io_req$FULL_N),
						   .EMPTY_N(m_io_req$EMPTY_N));

  // submodule m_io_rsp
  FIFO2 #(.width(32'd32), .guarded(1'd1)) m_io_rsp(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(m_io_rsp$D_IN),
						   .ENQ(m_io_rsp$ENQ),
						   .DEQ(m_io_rsp$DEQ),
						   .CLR(m_io_rsp$CLR),
						   .D_OUT(m_io_rsp$D_OUT),
						   .FULL_N(m_io_rsp$FULL_N),
						   .EMPTY_N(m_io_rsp$EMPTY_N));

  // submodule m_req_queue
  SizedFIFO0 #(.p1depth(32'd8),
	       .p2cntr_width(32'd4),
	       .guarded(1'd0)) m_req_queue(.RST(RST_N),
					   .CLK(CLK),
					   .ENQ(m_req_queue$ENQ),
					   .DEQ(m_req_queue$DEQ),
					   .CLR(m_req_queue$CLR),
					   .FULL_N(m_req_queue$FULL_N),
					   .EMPTY_N(m_req_queue$EMPTY_N));

  // submodule m_io_req
  assign m_io_req$D_IN = { WE_I, SEL_I, ADR_I, DAT_I } ;
  assign m_io_req$ENQ =
	     m_io_req_i_notFull_AND_m_req_queue_i_notFull_A_ETC___d5 ;
  assign m_io_req$DEQ = EN_client_request_get ;
  assign m_io_req$CLR = 1'b0 ;

  // submodule m_io_rsp
  assign m_io_rsp$D_IN = client_response_put ;
  assign m_io_rsp$ENQ = EN_client_response_put ;
  assign m_io_rsp$DEQ = CYC_I && m_io_rsp$EMPTY_N && m_req_queue$EMPTY_N ;
  assign m_io_rsp$CLR = 1'b0 ;

  // submodule m_req_queue
  assign m_req_queue$ENQ =
	     m_io_req_i_notFull_AND_m_req_queue_i_notFull_A_ETC___d5 ;
  assign m_req_queue$DEQ = CYC_I && m_io_rsp$EMPTY_N && m_req_queue$EMPTY_N ;
  assign m_req_queue$CLR = !CYC_I ;

  // remaining internal signals
  assign m_io_req_i_notFull_AND_m_req_queue_i_notFull_A_ETC___d5 =
	     m_io_req$FULL_N && m_req_queue$FULL_N && CYC_I && STB_I ;
endmodule  // mkWishboneSlaveXactor_32_32_8

